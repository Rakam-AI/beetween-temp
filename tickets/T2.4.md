# T2.4 - Implement Request Domain State Machine (TransitionEngine)


**Depends on:** T2.2
**Blocks:** T2.7, T2.8, T2.9, T2.10, T2.11

**Context:**
The Request lifecycle is a state machine with complex transition rules, especially around the validation modes (ONE vs ALL) and step progression. This is the core business logic.

Reference:
- `Agent_Technical Specification V1.0.md` > "Transitions d'une demande de recrutement" (full section)
- `API_Technical Specification V1.md` > "Modèles de données > Demande de recrutement" > status transitions

**Objective:**
Implement the state machine logic within the Request aggregate and/or a domain service (`TransitionEngine`). All transition rules must be enforced.

**Instructions:**

1. **In `Request.kt`, add transition methods:**

   a. **`submit(globalRequiredFields, stepRequiredFields) -> Result<RequestEvent, RequestError>`**
   - Pre-condition: status == DRAFT
   - Validate all globalRequiredFields and step 1's requiredFields are filled in businessInfo/additionalFieldValues
   - Transition: status = PENDING, currentStepIndex = 1
   - Add SUBMIT history entry
   - Return `RequestSubmitted` event

   b. **`approve(validatorId, validatorType, comment, workflowStep) -> Result<List<RequestEvent>, RequestError>`**
   - Pre-condition: status == PENDING
   - Pre-condition: validator is in the current step's validators list
   - Pre-condition: validator is NOT the request creator (creator cannot be validator)
   - Logic depends on `validationMode`:
     - **Mode ONE:**
       - Immediately progress: currentStepIndex += 1
       - If was last step: status = APPROVED
       - Return `RequestStepPassed` (or `RequestApproved` if final)
     - **Mode ALL:**
       - Add validator to `pendingValidators.approvedBy`
       - If all validators have approved: currentStepIndex += 1, clear pendingValidators
       - If was last step after all approved: status = APPROVED
       - Return `RequestStepApproved` (partial) or `RequestStepPassed` + potentially `RequestApproved`
   - Add APPROVE history entry
   - Handle concurrent approval: if already approved by this validator, return error

   c. **`reject(rejectorId, rejectorType, reason, comment) -> Result<RequestEvent, RequestError>`**
   - Pre-condition: status == PENDING
   - Pre-condition: rejector is a validator at current step
   - Pre-condition: rejector is NOT the request creator (creator cannot validate/reject their own request)
   - Transition: status = REJECTED, currentStepIndex stays the same
   - Reason is mandatory
   - Add REJECT history entry
   - Return `RequestRejected` event

   d. **`addComment(userId, userName, comment) -> Result<Unit, RequestError>`**
   - Pre-condition: status == PENDING (comments only during validation)
   - Add COMMENT history entry
   - No state change

   e. **`archive(userId, userName) -> Result<RequestEvent, RequestError>`**
   - Pre-condition: status in [DRAFT, APPROVED, REJECTED]
   - If DRAFT: status = ABANDONED (and return `RequestAbandoned`)
   - If APPROVED or REJECTED: status = ARCHIVED (and return `RequestArchived`)
   - Add ARCHIVE/ABANDON history entry

   f. **`update(newBusinessInfo, newAdditionalFields, userId, userName) -> Result<Unit, RequestError>`**
   - Pre-condition: status == DRAFT
   - Compute changed fields for history
   - Add UPDATE history entry
   - Update `updatedAt`

   g. **`duplicate() -> Request`**
   - Creates a new Request with the same businessInfo and additionalFieldValues
   - New status = DRAFT, currentStepIndex = 0
   - Clears history (starts fresh with CREATE entry)
   - Same workflowId

2. **Create helper method `isValidatorAtCurrentStep(actorId, workflowSteps) -> Boolean`**

3. **Create helper method `validateRequiredFields(fields, businessInfo, additionalFieldValues) -> List<String>` (returns missing field names)**

4. **Create `domain/request/service/TransitionEngine.kt`** if the logic is too complex for the aggregate:
   - This domain service coordinates transitions that need workflow information
   - Takes a `Request` and a `Workflow` and performs the transition

5. **Create comprehensive unit tests in `domain/request/model/RequestTest.kt`:**
   - Test create → submit (success with all fields)
   - Test create → submit (failure with missing fields)
   - Test submit → approve (mode ONE, single step → APPROVED)
   - Test submit → approve (mode ONE, multiple steps → still PENDING, step advances)
   - Test submit → approve (mode ALL, not all approved → still PENDING same step)
   - Test submit → approve (mode ALL, all approved → step advances)
   - Test submit → approve → approve → approve through multi-step workflow to APPROVED
   - Test submit → reject (→ REJECTED)
   - Test reject requires reason
   - Test duplicate of rejected request
   - Test archive from DRAFT (→ ABANDONED)
   - Test archive from APPROVED (→ ARCHIVED)
   - Test archive from REJECTED (→ ARCHIVED)
   - Test cannot submit when not DRAFT
   - Test cannot approve when not PENDING
   - Test cannot reject when not PENDING
   - Test concurrent approval (same validator twice → error)
   - Test update only in DRAFT
   - Test comment only in PENDING

**Acceptance Criteria:**
- All state transitions match the specification exactly
- Validation modes ONE and ALL work correctly
- Step progression works (currentStepIndex increments)
- History entries are recorded for every action
- Unit tests cover all paths (success + error cases)
- No infrastructure dependencies
