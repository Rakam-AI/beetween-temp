# T2.1 - Implement Workflow Domain Model


**Depends on:** T1.7
**Blocks:** T2.3, T2.5

**Context:**
The Workflow is one of the two main aggregates in the system. It defines the validation process that recruitment requests follow. A workflow contains ordered steps, each with validators, commentators, required/hidden/read-only fields, and a validation mode.

Reference:
- `Agent_Technical Specification V1.0.md` > "Gestion des workflows" (full section)
- `API_Technical Specification V1.md` > "DTOs communs > Workflow" and "Modèles de données > Workflow"

**Objective:**
Create the Workflow aggregate root and all related value objects in the domain layer. Only domain model and validation rules — no persistence, no endpoints.

**Instructions:**
Create the following classes in `domain/workflow/model/`:

1. **`WorkflowId.kt`** - Value class wrapping a UUID
   ```kotlin
   @JvmInline
   value class WorkflowId(val value: UUID) {
       companion object {
           fun generate(): WorkflowId = WorkflowId(UUID.randomUUID())
           fun from(value: String): WorkflowId = WorkflowId(UUID.fromString(value))
       }
   }
   ```

2. **`PublicationStatus.kt`** - Enum
   ```kotlin
   enum class PublicationStatus { DRAFT, PUBLISHED, UNPUBLISHED }
   ```

3. **`ValidationMode.kt`** - Enum
   ```kotlin
   enum class ValidationMode { ONE, ALL }
   ```

4. **`FieldType.kt`** - Enum (in `domain/shared/model/`)
   ```kotlin
   enum class FieldType { TEXT, NUMBER, DATE, DROPDOWN, CHECKBOX, FILE }
   ```

5. **`ActorReference.kt`** - Value object (in `domain/shared/model/`)
   ```kotlin
   data class ActorReference(
       val type: ActorType,
       val id: String
   )
   enum class ActorType { ROLE, USER }
   ```

6. **`WorkflowStep.kt`** - Value object
   ```kotlin
   data class WorkflowStep(
       val name: String,
       val description: String? = null,
       val icon: String? = null,
       val validationMode: ValidationMode,
       val validators: List<ActorReference>,
       val commentators: List<ActorReference> = emptyList(),
       val readOnlyViewers: List<ActorReference> = emptyList(),
       val requiredFields: List<String> = emptyList(),
       val hiddenFields: List<String> = emptyList(),
       val readOnlyFields: List<String> = emptyList()
   ) {
       init {
           require(name.isNotBlank()) { "Step name must not be blank" }
           require(validators.isNotEmpty()) { "Step must have at least one validator" }
       }
   }
   ```

7. **`AdditionalFieldDefinition.kt`** - Value object
   ```kotlin
   data class AdditionalFieldDefinition(
       val name: String,
       val label: String,
       val type: FieldType,
       val options: List<String> = emptyList(),
       val defaultValue: String? = null,
       val helpText: String? = null
   ) {
       init {
           require(name.isNotBlank()) { "Field name must not be blank" }
           require(label.isNotBlank()) { "Field label must not be blank" }
           if (type == FieldType.DROPDOWN) {
               require(options.isNotEmpty()) { "Dropdown fields must have options" }
           }
       }
   }
   ```

8. **`Workflow.kt`** - Aggregate Root
   ```kotlin
   class Workflow private constructor(
       val id: WorkflowId,
       var name: String,
       var description: String?,
       val createdBy: UUID,
       val companyId: UUID,
       val createdAt: Instant,
       var updatedAt: Instant,
       var publicationStatus: PublicationStatus,
       var steps: List<WorkflowStep>,
       var additionalFields: List<AdditionalFieldDefinition>,
       var globalRequiredFields: List<String>
   ) {
       companion object {
           fun create(
               name: String,
               description: String?,
               createdBy: UUID,
               companyId: UUID,
               steps: List<WorkflowStep>,
               additionalFields: List<AdditionalFieldDefinition> = emptyList(),
               globalRequiredFields: List<String> = emptyList()
           ): Workflow { /* factory method - validates and creates */ }
       }

       fun publish(): Result<Unit, WorkflowError> { /* DRAFT -> PUBLISHED */ }
       fun unpublish(): Result<Unit, WorkflowError> { /* PUBLISHED -> UNPUBLISHED */ }
       fun update(name: String, description: String?, steps: List<WorkflowStep>, ...): Result<Unit, WorkflowError> { /* Only if DRAFT */ }
       fun canBeDeleted(): Boolean { /* Only if not PUBLISHED and no active requests */ }
   }
   ```
   - Use `com.github.michaelbull.result.Result` for error handling
   - The `Workflow` must be immutable from the outside (use factory method pattern)

9. **Create `domain/workflow/error/WorkflowError.kt`:**
   ```kotlin
   sealed class WorkflowError {
       data object CannotModifyPublishedWorkflow : WorkflowError()
       data object CannotDeletePublishedWorkflow : WorkflowError()
       data object CannotDeleteWorkflowWithActiveRequests : WorkflowError()
       data object WorkflowAlreadyPublished : WorkflowError()
       data object WorkflowNotPublished : WorkflowError()
       data object InvalidStepConfiguration : WorkflowError()
   }
   ```

10. **Create `domain/workflow/event/WorkflowEvent.kt`:**
    ```kotlin
    sealed class WorkflowEvent {
        abstract val workflowId: WorkflowId
        abstract val companyId: UUID
        abstract val timestamp: Instant

        data class WorkflowCreated(...) : WorkflowEvent()
        data class WorkflowPublished(...) : WorkflowEvent()
        data class WorkflowUpdated(...) : WorkflowEvent()
    }
    ```

**Acceptance Criteria:**
- All classes compile with no dependencies on Spring or infrastructure
- Value objects have proper validation in `init` blocks
- `Workflow.create()` factory method validates: non-blank name, at least one step, each step has validators
- `publish()` only works from DRAFT status
- `unpublish()` only works from PUBLISHED status
- `update()` only works when DRAFT
- All classes use Kotlin idioms (data classes, sealed classes, value classes)
